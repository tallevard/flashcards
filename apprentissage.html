<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Révisions Flashcards — Apprentissage (multi-chapitres, relectures)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#111; --fg:#eee; --muted:#aaa; --accent:#4ea1ff; --ok:#98ffa6; --warn:#ffd27a; --err:#ff8a8a; }
    html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }
    h1 { font-size: 1.4rem; margin: 0 0 12px; }
    .card { background:#1b1b1b; border:1px solid #2a2a2a; border-radius:14px; padding:16px; box-shadow:0 6px 18px rgba(0,0,0,.25); }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    label { font-size:.95rem; color:var(--muted); }
    textarea { width:100%; padding:10px 12px; border-radius:10px; border:1px solid #333; background:#121212; color:#eee; outline:none; }
    textarea::placeholder { color:#666; }
    button { background:var(--accent); color:#031d33; border:none; border-radius:10px; padding:10px 16px; font-weight:600; cursor:pointer; }
    button.secondary { background:#2a2a2a; color:#ddd; }
    button.ok { background:#1f7a3f; color:#eaffee; }
    button.warn { background:#7a5a1f; color:#fff6e0; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .controls { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .muted { color:var(--muted); font-size:.9rem; }
    .status { font-size:.95rem; color:#ddd; }
    .status.ok { color:var(--ok); }
    .status.warn { color:var(--warn); }
    .status.err { color:var(--err); }
    .stage { margin-top:18px; background:#000; border-radius:14px; border:1px solid #2a2a2a; min-height:60vh;
      display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; }
    .stage .hud { position:absolute; top:10px; left:12px; right:12px; display:flex; justify-content:space-between;
      align-items:center; pointer-events:none; color:#ddd; font-size:.95rem; }
    .stage .hud .pill { background:rgba(255,255,255,.08); padding:6px 10px; border-radius:999px; }
    .stage img { max-width:100%; max-height:80vh; object-fit:contain; display:block; }
    .kbd { font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:.85rem; background:#222; border:1px solid #333; padding:1px 6px; border-radius:6px; color:#ddd; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Révisions Flashcards — <span style="opacity:.7;">Apprentissage</span></h1>

    <div class="card">
      <label for="mix">Collez votre sélection (autant de chapitres que vous voulez) :</label>
      <textarea id="mix" rows="4" placeholder="Exemples :
RAL : 1-10 sauf 4,5 ; CAL : 1-14 ; BIO : 3-9
ou
ral: 1-20; !3 ; cal: 10-30; 40-50; !22-25 ; Geo: 2-4"></textarea>

      <div class="row" style="margin-top:12px;">
        <div class="controls">
          <label><input type="checkbox" id="shuffle" checked> Mélanger</label>
          <label><input type="checkbox" id="pleinEcran"> Plein écran (F11)</label>
        </div>
        <div class="row" style="gap:8px; margin-left:auto;">
          <button id="btnExemple" class="secondary" type="button">Exemple</button>
          <button id="btnGo" type="button">Lancer</button>
        </div>
      </div>

      <div id="status" class="status" style="margin-top:10px;"></div>
    </div>

    <div class="stage" id="stage" style="display:none;">
      <div class="hud">
        <div class="pill" id="hudLeft">–</div>
        <div class="pill" id="hudRight">Espace: basculer • Entrée: Je connais • R: à revoir • F: plein écran</div>
      </div>
      <img id="img" alt="flashcard" />
    </div>

    <div class="row" style="margin-top:10px; gap:10px;">
      <button id="toggleBtn" class="secondary" style="display:none;" type="button">Basculer (Espace)</button>
      <button id="knowBtn" class="ok" style="display:none;" type="button">Je connais (Entrée)</button>
      <button id="reviewBtn" class="warn" style="display:none;" type="button">À revoir (R)</button>
    </div>
  </div>

<script>
/* ===== Parsing multi-chapitres (N blocs "CHAP : ...") ===== */
function parseChaptersBlocks(raw){
  const text = (raw||"").replace(/\r/g,"");
  const re = /([A-Za-z0-9]+)\s*:\s*/g; // CHAP peut contenir lettres/chiffres
  const blocks = {};
  const matches = [];
  let m;
  while ((m = re.exec(text)) !== null){
    matches.push({ chap: m[1], idx: m.index, after: re.lastIndex });
  }
  for (let i=0; i<matches.length; i++){
    const cur = matches[i];
    const next = matches[i+1];
    const content = text.slice(cur.after, next ? next.idx : text.length).trim();
    blocks[cur.chap] = content;
  }
  return blocks; // { "RAL": "1-10 sauf 4,5", "CAL": "1-14", ... }
}

function parseNumsWithExclusions(raw){
  if (!raw) return [];
  const parts = raw.split(/\b(sauf|except)\b/i);
  let inclRaw = raw, exclRaw = "";
  if (parts.length >= 3) { inclRaw = parts[0]; exclRaw = parts.slice(2).join(""); }
  const bang = inclRaw.match(/!\s*\d+(?:\s*-\s*\d+)?/g);
  if (bang) exclRaw = exclRaw ? (exclRaw + ";" + bang.join(";")) : bang.join(";");
  inclRaw = inclRaw.replace(/!\s*\d+(?:\s*-\s*\d+)?/g, "");

  const include = tokensToSet(inclRaw);
  const exclude = tokensToSet(exclRaw);
  return Array.from(include).filter(n => !exclude.has(n)).sort((a,b)=>a-b);

  function tokensToSet(s){
    const out = new Set();
    if (!s) return out;
    s = s.replace(/,/g, ";");
    for (const tok of s.split(";").map(t=>t.trim()).filter(Boolean)){
      const m = tok.match(/^(\d+)\s*-\s*(\d+)$/);
      if (m){
        let a = parseInt(m[1],10), b = parseInt(m[2],10);
        if (isNaN(a)||isNaN(b)) continue;
        const lo = Math.min(a,b), hi = Math.max(a,b);
        for (let i=lo;i<=hi;i++) out.add(i);
      } else {
        const n = parseInt(tok,10);
        if (!isNaN(n)) out.add(n);
      }
    }
    return out;
  }
}
function pad3(n){ return String(n).padStart(3,"0"); }

function buildItemsFromInput(raw){
  const blocks = parseChaptersBlocks(raw);
  const items = []; // { code:"RAL_001", variants:{chapRaw,chapUp,chapLo,num} }
  for (const [chapRaw, block] of Object.entries(blocks)){
    const nums = parseNumsWithExclusions(block);
    for (const n of nums){
      const v = { chapRaw:chapRaw.trim(), chapUp:chapRaw.trim().toUpperCase(),
                  chapLo:chapRaw.trim().toLowerCase(), num: pad3(n) };
      items.push({ code: `${v.chapUp}_${v.num}`, variants: v });
    }
  }
  return items;
}

/* ===== Résolution d’images tolérante casse/format ===== */
const exts = ["png","PNG","jpg","JPG","jpeg","JPEG","webp","WEBP"];

function folderCandidates(v){
  return Array.from(new Set([
    `FC_${v.chapRaw}_slices`,
    `FC_${v.chapUp}_slices`,
    `FC_${v.chapLo}_slices`,
  ]));
}
function baseCandidates(v){
  const n = v.num;
  return Array.from(new Set([
    `FC_${v.chapRaw}_${n}`,
    `FC_${v.chapUp}_${n}`,
    `FC_${v.chapLo}_${n}`,
  ]));
}

function preload(url){
  return new Promise(resolve=>{
    const im = new Image();
    im.onload = ()=> resolve(true);
    im.onerror = ()=> resolve(false);
    im.src = url;
  });
}

async function firstExistingImageMulti(v, face){
  for (const folder of folderCandidates(v)){
    for (const base of baseCandidates(v)){
      for (const ext of exts){
        const url = `${folder}/${base}_${face}.${ext}`;
        if (await preload(url)) return url;
      }
    }
  }
  return null;
}

/* ===== État ===== */
const state = {
  deck: [],          // [{code, recto, verso}]
  order: [],         // ordre principal (indices deck)
  idx: -1,           // position dans order
  face: "recto",
  shuffle: true,

  // Relectures multi-tours
  phase: "main",     // "main" puis "review"
  reviewRound: 0,    // 1,2,3...
  reviewSeed: new Set(),  // collecté pendant "main"
  reviewOrder: [],        // indices deck pour tour courant
  reviewIdx: -1,          // position dans reviewOrder
  reviewNext: new Set()   // collecté pendant relecture → tour suivant
};

/* ===== DOM ===== */
const $mix = document.getElementById("mix");
const $btnGo = document.getElementById("btnGo");
const $btnEx = document.getElementById("btnExemple");
const $shuffle = document.getElementById("shuffle");
const $pleinEcran = document.getElementById("pleinEcran");
const $status = document.getElementById("status");

const $stage = document.getElementById("stage");
const $img = document.getElementById("img");
const $hudLeft = document.getElementById("hudLeft");

const $toggleBtn = document.getElementById("toggleBtn");
const $knowBtn = document.getElementById("knowBtn");
const $reviewBtn = document.getElementById("reviewBtn");

/* ===== UI Helpers ===== */
function setStatus(msg, kind){ // kind: "ok"|"warn"|"err"|undefined
  $status.textContent = msg;
  $status.className = "status" + (kind ? (" " + kind) : "");
}
function shuffleInPlace(arr){
  for (let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
}

/* ===== Lancement ===== */
$btnEx.addEventListener("click", ()=>{
  $mix.value = "RAL : 1-10 sauf 4,5 ; CAL : 1-14 ; BIO : 3-9";
});
$btnGo.addEventListener("click", start);

async function start(){
  // reset
  state.shuffle = $shuffle.checked;
  state.deck = []; state.order = []; state.idx = -1; state.face = "recto";
  state.phase = "main"; state.reviewRound = 0;
  state.reviewSeed.clear(); state.reviewOrder = []; state.reviewIdx = -1; state.reviewNext.clear();

  const items = buildItemsFromInput($mix.value);
  if (items.length===0){
    setStatus("Saisir au moins un bloc : CHAP : 1-10 ; AUTRE : 3-6 sauf 4", "err"); return;
  }

  setStatus("Préparation… vérification recto/verso, dossiers et extensions…");

  const deck = [];
  const missing = [];
  for (const it of items){
    const recto = await firstExistingImageMulti(it.variants, "recto");
    const verso = await firstExistingImageMulti(it.variants, "verso");
    if (recto && verso) deck.push({ code: it.code, recto, verso });
    else missing.push(it.code);
  }

  if (deck.length===0){
    setStatus(`Aucune carte valide. Exemples introuvables: ${missing.slice(0,8).join(", ")}${missing.length>8?" …":""}`, "err"); return;
  }
  if (missing.length){
    setStatus(`Ignorées (incomplètes/introuvables) : ${missing.slice(0,10).join(", ")}${missing.length>10?" …":""}`, "warn");
  } else {
    setStatus(`OK : ${deck.length} cartes prêtes.`, "ok");
  }

  state.deck = deck;
  state.order = Array.from(deck.keys());
  if (state.shuffle) shuffleInPlace(state.order);

  // UI visible
  $stage.style.display = "";
  $toggleBtn.style.display = "";
  $knowBtn.style.display = "";
  $reviewBtn.style.display = "";
  $toggleBtn.disabled = $knowBtn.disabled = $reviewBtn.disabled = false;

  nextCardMain(true);

  if ($pleinEcran.checked) tryEnterFullscreen();
}

/* ===== Affichage ===== */
function currentEntry(){
  if (state.phase === "main"){
    if (state.idx<0 || state.idx>=state.order.length) return null;
    return state.deck[state.order[state.idx]];
  } else {
    if (state.reviewIdx<0 || state.reviewIdx>=state.reviewOrder.length) return null;
    const deckIdx = state.reviewOrder[state.reviewIdx];
    return state.deck[deckIdx];
  }
}
function render(){
  const e = currentEntry(); if (!e) return;
  const url = (state.face==="recto") ? e.recto : e.verso;
  $img.src = url;

  let posText = "";
  if (state.phase === "main"){
    posText = `${state.idx+1}/${state.order.length}`;
  } else {
    posText = `Relecture (tour ${state.reviewRound}) — ${state.reviewIdx+1}/${state.reviewOrder.length}`;
  }
  $hudLeft.textContent = `${e.code} — ${state.face} • ${posText}`;
}

/* ===== Actions ===== */
function toggleFace(){
  if (!currentEntry()) return;
  state.face = (state.face==="recto") ? "verso" : "recto";
  render();
}
function deckIndexOfCurrent(){
  if (state.phase === "main") return state.order[state.idx];
  return state.reviewOrder[state.reviewIdx];
}
function markKnow(){ // Entrée
  if (state.phase === "review"){
    const d = deckIndexOfCurrent();
    state.reviewNext.delete(d); // ne pas reconvoquer
    nextCardReview();
  } else {
    nextCardMain();
  }
}
function markReview(){ // R/r
  if (!currentEntry()) return;
  const d = deckIndexOfCurrent();
  if (state.phase === "main"){
    state.reviewSeed.add(d);   // à revoir après la passe principale
    nextCardMain();
  } else {
    state.reviewNext.add(d);   // reviendra au tour suivant
    nextCardReview();
  }
}

/* ===== Avancement : main → review tour 1 → review tour 2 → ... ===== */
function nextCardMain(first=false){
  if (!first){
    if (state.idx >= state.order.length - 1){
      if (state.reviewSeed.size > 0){
        state.phase = "review";
        state.reviewRound = 1;
        state.reviewOrder = Array.from(state.reviewSeed.values());
        if (state.shuffle) shuffleInPlace(state.reviewOrder);
        state.reviewIdx = -1;
        state.reviewNext.clear();
        setStatus(`Phase relecture (tour ${state.reviewRound}) : ${state.reviewOrder.length} carte(s).`, "warn");
        nextCardReview(true);
        return;
      } else {
        setStatus("Terminé : toutes les cartes ont été vues 👏", "ok");
        disableStudyButtons(); return;
      }
    }
    state.idx++;
  } else {
    state.idx = 0;
  }
  state.face = "recto"; render();
}
function nextCardReview(first=false){
  if (!first){
    if (state.reviewIdx >= state.reviewOrder.length - 1){
      if (state.reviewNext.size > 0){
        state.reviewRound += 1;
        state.reviewOrder = Array.from(state.reviewNext.values());
        if (state.shuffle) shuffleInPlace(state.reviewOrder);
        state.reviewIdx = -1;
        state.reviewNext.clear();
        setStatus(`Relecture (tour ${state.reviewRound}) : ${state.reviewOrder.length} carte(s) restantes.`, "warn");
        nextCardReview(true);
        return;
      } else {
        setStatus("Terminé : fin de la relecture 👏", "ok");
        disableStudyButtons(); return;
      }
    }
    state.reviewIdx++;
  } else {
    state.reviewIdx = 0;
  }
  state.face = "recto"; render();
}
function disableStudyButtons(){
  $toggleBtn.disabled = true; $knowBtn.disabled = true; $reviewBtn.disabled = true;
}

/* ===== Raccourcis clavier (désactivés quand on tape) ===== */
function isTypingInField(e) {
  const t = e.target;
  return t && (t.tagName === "TEXTAREA" || t.tagName === "INPUT" || t.isContentEditable);
}
window.addEventListener("keydown", (e)=>{
  if (isTypingInField(e)) return;
  if (e.key === " "){ e.preventDefault(); toggleFace(); }         // basculer
  else if (e.key === "Enter"){ e.preventDefault(); markKnow(); }  // je connais
  else if (e.key === "r" || e.key === "R"){ e.preventDefault(); markReview(); } // à revoir
  else if (e.key === "f" || e.key === "F"){ tryEnterFullscreen(); } // plein écran
});

/* ===== Boutons ===== */
document.getElementById("toggleBtn").addEventListener("click", toggleFace);
document.getElementById("knowBtn").addEventListener("click", markKnow);
document.getElementById("reviewBtn").addEventListener("click", markReview);

/* ===== Plein écran ===== */
function tryEnterFullscreen(){
  const el = document.documentElement;
  if (!document.fullscreenElement){ if (el.requestFullscreen) el.requestFullscreen(); }
  else { if (document.exitFullscreen) document.exitFullscreen(); }
}
</script>
</body>
</html>
