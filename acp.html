<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>ACP dynamique</title>
<style>
  body { font-family: sans-serif; }
  canvas { border: 1px solid #ccc; margin-top: 20px; }
</style>
</head>

<body>
<h2>Analyse en Composantes Principales (ACP) – Données générées aléatoirement</h2>
<p>Les points sont régénérés à chaque rafraîchissement. La ligne rouge est la première composante principale.</p>

<canvas id="pcaCanvas" width="500" height="500"></canvas>

<script>
// --- 1. Génération aléatoire du nuage de points corrélés ---
function generateData(n = 40) {
  const pts = [];
  for (let i = 0; i < n; i++) {
    // Génère un nuage allongé : x aléatoire, y ≈ x + bruit
    const x = Math.random()*4 - 2;      // entre -2 et 2
    const y = x * 0.8 + (Math.random()*0.8 - 0.4);
    pts.push([x, y]);
  }
  return pts;
}

const data = generateData();


// --- 2. Centrage des données ---
function mean(arr) {
  return arr.reduce((s, x) => s + x, 0) / arr.length;
}

let mx = mean(data.map(p => p[0]));
let my = mean(data.map(p => p[1]));

let X = data.map(p => [p[0] - mx, p[1] - my]);


// --- 3. SVD 2x2 analytique pour obtenir l'axe principal ---
function svd2x2(M) {
  const [a, b] = M[0];
  const [c, d] = M[1];

  const A = a*a + c*c;
  const B = a*b + c*d;
  const C = b*b + d*d;

  const trace = A + C;
  const det = A*C - B*B;
  const lambda1 = trace/2 + Math.sqrt((trace/2)**2 - det);

  let v1 = [B, lambda1 - A];
  const norm = Math.hypot(v1[0], v1[1]);
  v1 = v1.map(x => x / norm);

  return {v1};
}

// Construire M = X^T X
let sumXX = 0, sumXY = 0, sumYY = 0;
for (let p of X) {
  sumXX += p[0]*p[0];
  sumXY += p[0]*p[1];
  sumYY += p[1]*p[1];
}
const M = [[sumXX, sumXY], [sumXY, sumYY]];
const {v1} = svd2x2(M);


// --- 4. Projection des données ---
const projected = X.map(p => {
  const t = p[0]*v1[0] + p[1]*v1[1];
  return [t*v1[0], t*v1[1]];
});


// --- 5. Dessin ---
const canvas = document.getElementById("pcaCanvas");
const ctx = canvas.getContext("2d");

function toCanvas(x, y) {
  return [
    250 + 80*x,
    250 - 80*y
  ];
}

function drawPoint(x, y, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, 3.5, 0, 2*Math.PI);
  ctx.fill();
}

ctx.clearRect(0,0,500,500);

// Points originaux
for (let p of X) {
  const [cx, cy] = toCanvas(p[0], p[1]);
  drawPoint(cx, cy, "blue");
}

// Axe principal (ligne rouge)
ctx.strokeStyle = "red";
ctx.beginPath();
let [ax1, ay1] = toCanvas(-3*v1[0], -3*v1[1]);
let [ax2, ay2] = toCanvas(3*v1[0], 3*v1[1]);
ctx.moveTo(ax1, ay1);
ctx.lineTo(ax2, ay2);
ctx.stroke();

// Projections (points verts)
for (let p of projected) {
  const [cx, cy] = toCanvas(p[0], p[1]);
  drawPoint(cx, cy, "green");
}
</script>

</body>
</html>
