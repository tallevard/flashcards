<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Exemple d'ACP</title>
<style>
  body { font-family: sans-serif; }
  canvas { border: 1px solid #ccc; margin-top: 20px; }
</style>
</head>

<body>
<h2>Exemple d'Analyse en Composantes Principales (ACP)</h2>

<p>Les points bleus sont les données originales, la ligne rouge est la première composante principale, et les points verts sont les projections.</p>

<canvas id="pcaCanvas" width="500" height="500"></canvas>

<script>
// --- 1. Jeu de données (un nuage orienté) ---
const data = [
  [2.0, 1.2], [2.2, 1.4], [2.4, 1.5], [2.6, 1.7], [2.8, 2.0],
  [3.0, 2.1], [3.2, 2.3], [3.4, 2.4], [3.6, 2.6], [3.8, 2.8]
];

// --- 2. Centrage des données ---
function mean(arr) {
  return arr.reduce((s, x) => s + x, 0) / arr.length;
}

let mx = mean(data.map(p => p[0]));
let my = mean(data.map(p => p[1]));

let X = data.map(p => [p[0] - mx, p[1] - my]);

// --- 3. Calcul de la SVD 2x2 (analytique pour simplifier)
function svd2x2(M) {
  // M est une matrice 2x2 : [[a, b], [c, d]]
  const [a, b] = M[0];
  const [c, d] = M[1];

  // On calcule M^T M
  const A = a*a + c*c;
  const B = a*b + c*d;
  const C = b*b + d*d;

  // valeurs propres de M^T M
  const trace = A + C;
  const det = A*C - B*B;
  const lambda1 = trace/2 + Math.sqrt((trace/2)**2 - det);
  const lambda2 = trace/2 - Math.sqrt((trace/2)**2 - det);

  const sigma1 = Math.sqrt(lambda1);
  const sigma2 = Math.sqrt(lambda2);

  // vecteur propre associé à lambda1
  let v1 = [B, lambda1 - A];
  const norm = Math.hypot(v1[0], v1[1]);
  v1 = v1.map(x => x / norm);

  return {sigma1, sigma2, v1};
}

// Construire la matrice X (n×2)
let sumXX = 0, sumXY = 0, sumYY = 0;
for (let p of X) {
  sumXX += p[0]*p[0];
  sumXY += p[0]*p[1];
  sumYY += p[1]*p[1];
}

const M = [[sumXX, sumXY], [sumXY, sumYY]];
const {v1} = svd2x2(M);  // première composante principale

// --- 4. Projection des données ---
const projected = X.map(p => {
  const t = p[0]*v1[0] + p[1]*v1[1];  // projection scalaire
  return [t*v1[0], t*v1[1]];
});

// --- 5. Affichage ---
const canvas = document.getElementById("pcaCanvas");
const ctx = canvas.getContext("2d");

function toCanvas(x, y) {
  return [
    250 + 60*x,
    250 - 60*y
  ];
}

function drawPoint(x, y, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2*Math.PI);
  ctx.fill();
}

ctx.clearRect(0,0,500,500);

// Points originaux
for (let p of X) {
  const [cx, cy] = toCanvas(p[0], p[1]);
  drawPoint(cx, cy, "blue");
}

// Axe principal
ctx.strokeStyle = "red";
ctx.beginPath();
let [ax1, ay1] = toCanvas(-3*v1[0], -3*v1[1]);
let [ax2, ay2] = toCanvas(3*v1[0], 3*v1[1]);
ctx.moveTo(ax1, ay1);
ctx.lineTo(ax2, ay2);
ctx.stroke();

// Projections
for (let p of projected) {
  const [cx, cy] = toCanvas(p[0], p[1]);
  drawPoint(cx, cy, "green");
}
</script>

</body>
</html>
