<html lang="fr">
<head>
<meta charset="UTF-8">
<title>ACP avec orientation aléatoire</title>
<style>
  body { font-family: sans-serif; }
  canvas { border: 1px solid #aaa; margin-top: 20px; }
</style>
</head>

<body>
<h2>Analyse en Composantes Principales — Orientation aléatoire</h2>
<p>Le nuage est tourné aléatoirement à chaque rechargement. La composante principale (en rouge) suit la covariance.</p>

<canvas id="pcaCanvas" width="500" height="500"></canvas>

<script>
// --- Génère un nuage corrélé, puis le tourne aléatoirement ---
function generateRotatedData(n = 40) {
  const base = [];
  for (let i = 0; i < n; i++) {
    const x = Math.random()*4 - 2;
    const y = 0.8*x + (Math.random()*0.7 - 0.35);
    base.push([x, y]);
  }
  // rotation aléatoire
  const theta = Math.random() * 2 * Math.PI;
  const cos = Math.cos(theta), sin = Math.sin(theta);
  return base.map(([x,y]) => [cos*x - sin*y, sin*x + cos*y]);
}

const data = generateRotatedData();

// --- Centrage ---
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
const mx = mean(data.map(p=>p[0]));
const my = mean(data.map(p=>p[1]));
const X = data.map(([x,y])=>[x-mx, y-my]);

// --- Calcul de X^T X ---
let xx=0, xy=0, yy=0;
for (let [x,y] of X){ xx+=x*x; xy+=x*y; yy+=y*y; }
const M = [[xx,xy],[xy,yy]];

// --- Extraction du vecteur propre dominant (ACP1) ---
function eigenVectorMax(A){
  const [a,b]=A[0], [c,d]=A[1];
  const tr = a+d;
  const det = a*d - b*c;
  const lambda = tr/2 + Math.sqrt((tr/2)**2 - det);
  let v = [b, lambda - a];
  const n = Math.hypot(...v);
  return v.map(x=>x/n);
}

const v1 = eigenVectorMax(M);

// --- Projection ---
const projected = X.map(([x,y])=>{
  const t = x*v1[0] + y*v1[1];
  return [t*v1[0], t*v1[1]];
});

// --- Affichage ---
const canvas = document.getElementById("pcaCanvas");
const ctx = canvas.getContext("2d");

function toCanvas(x,y){ return [250 + 80*x, 250 - 80*y]; }

function drawPoint(x,y,color){
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(x,y,3,0,2*Math.PI);
  ctx.fill();
}

ctx.clearRect(0,0,500,500);

// points
for (let p of X){
  const [cx,cy] = toCanvas(...p);
  drawPoint(cx,cy,"blue");
}

// axe principal
ctx.strokeStyle = "red";
ctx.beginPath();
let [ax1,ay1] = toCanvas(-3*v1[0], -3*v1[1]);
let [ax2,ay2] = toCanvas( 3*v1[0],  3*v1[1]);
ctx.moveTo(ax1,ay1);
ctx.lineTo(ax2,ay2);
ctx.stroke();

// projections
for (let p of projected){
  const [cx,cy] = toCanvas(...p);
  drawPoint(cx,cy,"green");
}
</script>

</body>
</html>
